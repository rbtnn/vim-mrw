" ___vital___
" NOTE: lines between '" ___vital___' is generated by :Vitalize.
" Do not modify the code nor insert new lines before '" ___vital___'
function! s:_SID() abort
  return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
endfunction
execute join(['function! vital#_mrw#PopupWin#import() abort', printf("return map({'enhance_menufilter': ''}, \"vital#_mrw#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
delfunction s:_SID
" ___vital___

let s:NO_MATCHES_KEY = 'no_matches'
let s:NO_MATCHES_DEF = 'no matches'

let s:PREFIX = 'vital_PopupWin_'

let s:KEY_LINES = s:PREFIX .. 'lines'
let s:KEY_OPTIONS = s:PREFIX .. 'options'



function! s:enhance_menufilter(winid, options) abort
    let lines = getbufline(winbufnr(a:winid), 1, '$')
    let a:options['filter_text'] = get(a:options, 'filter_text', '')
    let a:options['cursorline'] = get(a:options, 'cursorline', 1)
    " clear, due to call _update_lines
    let a:options['prev_filter_text'] = ''
    call setwinvar(a:winid, s:KEY_LINES, lines)
    call setwinvar(a:winid, s:KEY_OPTIONS, a:options)
    call popup_setoptions(a:winid, s:_menu_opt(a:winid, len(lines), len(lines)))
    call s:_update_lines(a:winid, {-> a:options['filter_text'] }, v:null)
    call s:_set_cursorline(a:winid, a:options['cursorline'])
endfunction



function! s:_filter(winid, key) abort
    let opts = getwinvar(a:winid, s:KEY_OPTIONS)
    if '/' == a:key
        try
            let timer = timer_start(100, function('s:_update_lines', [(a:winid), function('getcmdline')]), #{ repeat: -1, })
            augroup vital-popupwin
                autocmd!
                execute printf('autocmd CmdWinEnter  * :call popup_hide(%d)', a:winid)
                execute printf('autocmd CmdWinLeave  * :call popup_show(%d) | redraw', a:winid)
            augroup END
            let filter_text = input('/', getwinvar(a:winid, s:KEY_OPTIONS)['filter_text'])
        finally
            augroup vital-popupwin
                autocmd!
            augroup END
            call timer_stop(timer)
        endtry
        call s:_update_lines(a:winid, {-> filter_text }, timer)
        return 1
    elseif 'g' == a:key
        call s:_set_cursorline(a:winid, 1)
        return 1
    elseif 'G' == a:key
        call s:_set_cursorline(a:winid, line('$', a:winid))
        return 1
    endif
    let opts['cursorline'] = line('.', a:winid)
    return popup_filter_menu(a:winid, a:key)
endfunction

function! s:_update_lines(winid, F, timer) abort
    let opts = getwinvar(a:winid, s:KEY_OPTIONS)
    let opts['filter_text'] = trim(a:F())
    if opts['prev_filter_text'] != opts['filter_text']
        let opts['prev_filter_text'] = opts['filter_text']
        let lines = deepcopy(getwinvar(a:winid, s:KEY_LINES))
        let orig_len = len(lines)
        call filter(lines, { i,x -> -1 != match(x, opts['filter_text']) })
        let filter_len = len(lines)
        call win_execute(a:winid, 'call clearmatches()')
        if !empty(lines)
            call popup_settext(a:winid, lines)
            call win_execute(a:winid, printf('call matchadd("%s", getwinvar(winnr(), "%s")["filter_text"])', 'Search', s:KEY_OPTIONS))
        else
            let opts = getwinvar(a:winid, s:KEY_OPTIONS)
            call popup_settext(a:winid, get(opts, s:NO_MATCHES_KEY, s:NO_MATCHES_DEF))
        endif
        call popup_setoptions(a:winid, s:_menu_opt(a:winid, filter_len, orig_len))
        redraw
    endif
endfunction

" This is a function but a script's variable, due to must re-evaluate &columns and &lines.
function! s:_menu_opt(winid, filter_len, orig_len) abort
    let opts = getwinvar(a:winid, s:KEY_OPTIONS)
    let retval = extend({
        \   'maxheight' : &lines / 3,
        \   'minheight' : &lines / 3,
        \   'maxwidth' : &columns - 4,
        \   'minwidth' : &columns - 4,
        \   'pos' : 'topleft',
        \   'line' : &lines + 1,
        \   'col' : 1,
        \   'border' : [0,0,0,0],
        \ }, opts, 'force')

    " force overrides
    let retval['title'] = printf('%s (%d/%d) %s', get(opts, 'title', ''),
        \ a:filter_len, a:orig_len, empty(opts['filter_text']) ? '' : '/' .. opts['filter_text'])
    let retval['filter'] = function('s:_filter')

    return retval
endfunction

function! s:_set_cursorline(winid, lnum) abort
    call win_execute(a:winid, printf('call setpos(".", [0, %d, 0, 0])', a:lnum))
    call win_execute(a:winid, 'redraw!')
endfunction

