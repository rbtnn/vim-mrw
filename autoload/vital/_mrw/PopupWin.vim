" ___vital___
" NOTE: lines between '" ___vital___' is generated by :Vitalize.
" Do not modify the code nor insert new lines before '" ___vital___'
function! s:_SID() abort
  return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
endfunction
execute join(['function! vital#_mrw#PopupWin#import() abort', printf("return map({'filter': '', 'enhance_menufilter': '', 'xxx': '', 'enhance_filter': ''}, \"vital#_mrw#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
delfunction s:_SID
" ___vital___

let s:NO_MATCHES_KEY = 'no_matches'
let s:NO_MATCHES_DEF = 'no matches'

let s:PREFIX = 'vital_PopupWin_'

let s:KEY_LINES = s:PREFIX .. 'lines'
let s:KEY_FILTEXT = s:PREFIX .. 'filter_text'
let s:KEY_PREVFILTEXT = s:PREFIX .. 'prev_filter_text'
let s:KEY_OPTIONS = s:PREFIX .. 'options'



function! s:enhance_menufilter(winid, options) abort
    let lines = getbufline(winbufnr(a:winid), 1, '$')
    call setwinvar(a:winid, s:KEY_LINES, lines)
    call setwinvar(a:winid, s:KEY_FILTEXT, '')
    call setwinvar(a:winid, s:KEY_OPTIONS, a:options)
    call popup_setoptions(a:winid, s:_menu_opt(a:winid, len(lines), len(lines)))
endfunction



function! s:_filter(winid, key) abort
    if '/' == a:key
        try
            let timer = timer_start(100, function('s:_update_lines', [(a:winid), function('getcmdline')]), #{ repeat: -1, })
            augroup vital-popupwin
                autocmd!
                execute printf('autocmd CmdWinEnter  * :call popup_hide(%d)', a:winid)
                execute printf('autocmd CmdWinLeave  * :call popup_show(%d) | redraw', a:winid)
            augroup END
            let filter_text = input('/', getwinvar(a:winid, s:KEY_FILTEXT))
        finally
            augroup vital-popupwin
                autocmd!
            augroup END
            call timer_stop(timer)
        endtry
        call s:_update_lines(a:winid, {-> filter_text }, timer)
        return 1
    elseif 'g' == a:key
        call win_execute(a:winid, printf('call setpos(".", [0, %d, 0, 0])', 1))
        return 1
    elseif 'G' == a:key
        call win_execute(a:winid, printf('call setpos(".", [0, %d, 0, 0])', line('$', a:winid)))
        return 1
    endif
    return popup_filter_menu(a:winid, a:key)
endfunction

function! s:_update_lines(winid, F, timer) abort
    let filter_text = a:F()
    if getwinvar(a:winid, s:KEY_PREVFILTEXT) != filter_text
        call setwinvar(a:winid, s:KEY_PREVFILTEXT, filter_text)
        let lines = deepcopy(getwinvar(a:winid, s:KEY_LINES))
        let orig_len = len(lines)
        call filter(lines, { i,x -> -1 != match(x, filter_text) })
        let filter_len = len(lines)
        call setwinvar(a:winid, s:KEY_FILTEXT, trim(filter_text))
        call win_execute(a:winid, 'call clearmatches()')
        if !empty(lines)
            call popup_settext(a:winid, lines)
            call win_execute(a:winid, printf('call matchadd("%s", getwinvar(winnr(), "%s"))', 'Search', s:KEY_FILTEXT))
        else
            let opts = getwinvar(a:winid, s:KEY_OPTIONS)
            call popup_settext(a:winid, get(opts, s:NO_MATCHES_KEY, s:NO_MATCHES_DEF))
        endif
        call popup_setoptions(a:winid, s:_menu_opt(a:winid, filter_len, orig_len))
        redraw
    endif
endfunction

" This is a function but a script's variable, due to must re-evaluate &columns and &lines.
function! s:_menu_opt(winid, filter_len, orig_len) abort
    let opts = getwinvar(a:winid, s:KEY_OPTIONS)
    let retval = extend({
        \   'maxheight' : &lines / 3,
        \   'minheight' : &lines / 3,
        \   'maxwidth' : &columns - 4,
        \   'minwidth' : &columns - 4,
        \   'pos' : 'topleft',
        \   'line' : &lines + 1,
        \   'col' : 1,
        \   'border' : [0,0,0,0],
        \ }, opts, 'force')

    " force overrides
    let retval['title'] = printf('%s (%d/%d)', get(opts, 'title', ''), a:filter_len, a:orig_len)
    let retval['filter'] = function('s:_filter')

    return retval
endfunction

